% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/NMF-class.R, R/fixed-terms.R
\docType{class}
\name{NMF-class}
\alias{NMF-class}
\alias{show,NMF-method}
\alias{misc}
\alias{$,NMF-method}
\alias{$<-,NMF-method}
\alias{.DollarNames,NMF-method}
\alias{c,NMF-method}
\title{Generic Interface for Nonnegative Matrix Factorisation Models}
\usage{
\S4method{show}{NMF}(object)

misc(object, ...)

\S4method{$}{NMF}(x, name)

\S4method{$}{NMF}(x, name) <- value

\S4method{.DollarNames}{NMF}(x, pattern = "")

\S4method{c}{NMF}(x, ..., margin = 3L, recursive = FALSE)
}
\arguments{
\item{object}{an object that inherit from class \code{NMF}}

\item{...}{other objects to concatenate. Currently only two objects at a time
can be concatenated (i.e. \code{x} and \code{..1}).}

\item{x}{an NMF model}

\item{margin}{integer that indicates the margin along which to concatenate
(only used when \code{..1} is a matrix):
\describe{
\item{1L}{}
\item{2L}{}
\item{3L}{}
\item{4L}{}
}
If missing the margin is heuristically determined by looking at common
dimensions between the objects.}
}
\description{
The class \code{NMF} is a \emph{virtual class} that defines a common
interface to handle Nonnegative Matrix Factorization models (NMF models)
in a generic way.
Provided a minimum set of generic methods is implemented by concrete
model classes, these benefit from a whole set of functions and utilities
to perform common computations and tasks in the context of Nonnegative Matrix
Factorization.
}
\details{
Class \code{NMF} makes it easy to develop new models that integrate well
into the general framework implemented by the \emph{NMF} package.

Following a few simple guidelines, new types of NMF models benefit from all the
functionalities available for the built-in NMF models -- that derive themselves
from class \code{NMF}.
See section \emph{Implementing NMF models} below.

See \code{\linkS4class{NMFstd}}, and references and links therein for
details on the built-in implementations of the standard NMF model and its
extensions.
}
\section{Functions}{
\itemize{
\item \code{misc}: The function \code{misc} provides access to miscellaneous data members stored
in slot \code{misc} (as a \code{list}), which allow extensions of NMF models
to be implemented, without defining a new S4 class.
}}

\section{Slots}{

\describe{
\item{\code{misc}}{A list that is used internally to temporarily store algorithm
parameters during the computation.}
}}

\section{Implementing NMF models}{


The class \code{NMF} only defines a basic data/low-level interface for NMF models, as
a collection of generic methods, responsible with data handling, upon which
relies a comprehensive set of functions, composing a rich higher-level interface.

Actual NMF models are defined as sub-classes that inherits from class
\code{NMF}, and implement the management of data storage, providing
definitions for the interface's pure virtual methods.

The minimum requirement to define a new NMF model that integrates into
the framework of the \emph{NMF} package are the followings:

\itemize{

\item Define a class that inherits from class \code{NMF} and implements the
new model, say class \code{myNMF}.

\item Implement the following S4 methods for the new class \code{myNMF}:
\describe{
\item{fitted}{\code{signature(object = "myNMF", value = "matrix")}:
Must return the estimated target matrix as fitted by the NMF model
\code{object}.
}
\item{basis}{\code{signature(object = "myNMF")}:
Must return the basis matrix(e.g. the first matrix factor in
the standard NMF model).
}
\item{basis<-}{\code{signature(object = "myNMF", value = "matrix")}:
Must return \code{object} with the basis matrix set to
\code{value}.
}
\item{coef}{\code{signature(object = "myNMF")}:
Must return the matrix of mixture coefficients (e.g. the second matrix
factor in the standard NMF model).
}
\item{coef<-}{\code{signature(object = "myNMF", value = "matrix")}:
Must return \code{object} with the matrix of mixture coefficients set to
\code{value}.
}
}\preformatted{The \\emph\{NMF\} package provides "pure virtual" definitions of these
}

methods for class \code{NMF} (i.e. with signatures \code{(object='NMF', ...)}
and \code{(object='NMF', value='matrix')}) that throw an error if called, so
as to force their definition for model classes.

\item Optionally, implement method \code{rnmf}(signature(x="myNMF", target="ANY")).
This method should call \code{callNextMethod(x=x, target=target, ...)} and
fill the returned NMF model with its specific data suitable random values.
}

For concrete examples of NMF models implementations, see class
\code{\linkS4class{NMFstd}} and its extensions (e.g. classes
\code{\linkS4class{NMFOffset}} or \code{\linkS4class{NMFns}}).
}

\section{Creating NMF objects}{

Strictly speaking, because class \code{NMF} is virtual, no object of class
\code{NMF} can be instantiated, only objects from its sub-classes.
However, those objects are sometimes shortly referred in the documentation and
vignettes as "\code{NMF} objects" instead of "objects that inherits from
class \code{NMF}".

For built-in models or for models that inherit from the standard model class
\code{\linkS4class{NMFstd}}, the factory method \code{nmfModel} enables to easily create
valid \code{NMF} objects in a variety of common situations.
See documentation for the the factory method \code{\link{nmfModel}} for
more details.
}

\examples{

# show all the NMF models available (i.e. the classes that inherit from class NMF)
nmfModels()
# show all the built-in NMF models available
nmfModels(builtin.only=TRUE)

# class NMF is a virtual class so cannot be instantiated: 
try( new('NMF') )

# To instantiate an NMF model, use the factory method nmfModel. see ?nmfModel
nmfModel()
nmfModel(3)
nmfModel(3, model='NMFns')

}
\references{
Definition of Nonnegative Matrix Factorization in its modern formulation: Lee DD, Seung HS (1999). “Learning the parts of objects by non-negative
matrix factorization.” _Nature_, *401*(6755), 788-91. ISSN 0028-0836,
doi: 10.1038/44565 (URL: https://doi.org/10.1038/44565).

Historical first definition and algorithms: Paatero P, Tapper U (1994). “Positive matrix factorization: A
non-negative factor model with optimal utilization of error estimates
of data values.” _Environmetrics_, *5*(2), 111-126. doi:
10.1002/env.3170050203 (URL: https://doi.org/10.1002/env.3170050203).
}
\seealso{
Main interface function \link{nmf} to perform NMF.

Built-in NMF models and factory method in \code{\link{nmfModel}}.

Method \code{\link{seed}} to set NMF objects with values suitable to start
algorithms with.

Other NMF-interface: 
\code{\link{basis}()},
\code{\link{nmfModel}()},
\code{\link{rnmf}()}
}
\concept{NMF-interface}
\concept{NMF-model Implementations of NMF models}
\keyword{internal}
\section{Methods (by generic)}{
\bold{.basis:}

\itemize{
\item \code{.basis(object = NMF)}: Pure virtual method for objects of class \code{\linkS4class{NMF}}, that
should be overloaded by sub-classes, and throws an error if called.
}


\bold{.basis<-:}

\itemize{
\item \code{.basis<-(object = NMF,value = mMatrix)}: Pure virtual method for objects of class \code{\linkS4class{NMF}}, that
should be overloaded by sub-classes, and throws an error if called.
}


\bold{.coef:}

\itemize{
\item \code{.coef(object = NMF)}: Pure virtual method for objects of class \code{\linkS4class{NMF}}, that
should be overloaded by sub-classes, and throws an error if called.
}


\bold{.coef<-:}

\itemize{
\item \code{.coef<-(object = NMF,value = mMatrix)}: Pure virtual method for objects of class \code{\linkS4class{NMF}}, that
should be overloaded by sub-classes, and throws an error if called.
}


\bold{$:}

\itemize{
\item \code{$(x = NMF)}: shortcut for \code{x@misc[[name, exact=TRUE]]} respectively.
}


\bold{$<-:}

\itemize{
\item \code{$<-(x = NMF)}: shortcut for \code{x@misc[[name]] <- value}
}


\bold{basis<-:}

\itemize{
\item \code{basis<-(object = NMF)}: Default methods that calls \code{.basis<-} and check the validity of the
updated object.
}


\bold{basiscor:}

\itemize{
\item \code{basiscor(x = NMF,y = matrix)}: Computes the correlations between the basis vectors of \code{x} and
the columns of \code{y}.

\item \code{basiscor(x = matrix,y = NMF)}: Computes the correlations between the columns of \code{x}
and the the basis vectors of \code{y}.

\item \code{basiscor(x = NMF,y = NMF)}: Computes the correlations between the basis vectors of \code{x} and \code{y}.

\item \code{basiscor(x = NMF,y = missing)}: Computes the correlations between the basis vectors of \code{x}.
}


\bold{basismap:}

\itemize{
\item \code{basismap(object = NMF)}: Plots a heatmap of the basis matrix of the NMF model \code{object}.
This method also works for fitted NMF models (i.e. \code{NMFfit} objects).
}


\bold{c:}

\itemize{
\item \code{c(x = NMF)}: Concatenating NMF Models

Binds compatible matrices and NMF models together.
}


\bold{canFit:}

\itemize{
\item \code{canFit(x = NMFStrategy,y = NMF)}: Tells if an NMF algorithm can fit the same class of models as \code{y}
}


\bold{coef<-:}

\itemize{
\item \code{coef<-(object = NMF)}: Default methods that calls \code{.coef<-} and check the validity of the
updated object.
}


\bold{coefficients:}

\itemize{
\item \code{coefficients(object = NMF)}: Alias to \code{coef,NMF}, therefore also pure virtual.
}


\bold{coefmap:}

\itemize{
\item \code{coefmap(object = NMF)}: The default method for NMF objects has special default values for
some arguments of \code{\link{aheatmap}} (see argument description).
}


\bold{connectivity:}

\itemize{
\item \code{connectivity(object = NMF)}: Computes the connectivity matrix for an NMF model, for which cluster
membership is given by the most contributing basis component in each sample.
See \code{\link{predict,NMF-method}}.
}


\bold{consensus:}

\itemize{
\item \code{consensus(object = NMF)}: This method is provided for completeness and is identical to
\code{\link{connectivity}}, and returns the connectivity matrix,
which, in the case of a single NMF model, is also the consensus matrix.
}


\bold{consensushc:}

\itemize{
\item \code{consensushc(object = NMF)}: Compute the hierarchical clustering on the connectivity matrix of \code{object}.
}


\bold{consensusmap:}

\itemize{
\item \code{consensusmap(object = NMF)}: Plots a heatmap of the connectivity matrix of an NMF model.
}


\bold{deviance:}

\itemize{
\item \code{deviance(object = NMF)}: Computes the distance between a matrix and the estimate of an \code{NMF} model.
}


\bold{extractFeatures:}

\itemize{
\item \code{extractFeatures(object = NMF)}: Select basis-specific features from an NMF model, by applying the method
\code{extractFeatures,matrix} to its basis matrix.
}


\bold{featureScore:}

\itemize{
\item \code{featureScore(object = NMF)}: Computes feature scores on the basis matrix of an NMF model.
}


\bold{fit<-:}

\itemize{
\item \code{fit<-(object = NMFfit,value = NMF)}: Updates the NMF model object stored in slot \code{'fit'} with a new value.
}


\bold{fitted:}

\itemize{
\item \code{fitted(object = NMF)}: Pure virtual method for objects of class \code{\linkS4class{NMF}}, that
should be overloaded by sub-classes, and throws an error if called.
}


\bold{ibterms:}

\itemize{
\item \code{ibterms(object = NMF)}: Default pure virtual method that ensure a method is defined for concrete
NMF model classes.
}


\bold{icterms:}

\itemize{
\item \code{icterms(object = NMF)}: Default pure virtual method that ensure a method is defined for concrete
NMF model classes.
}


\bold{metaHeatmap:}

\itemize{
\item \code{metaHeatmap(object = NMF)}: Deprecated method that is substituted by \code{\link{coefmap}} and \code{\link{basismap}}.
}


\bold{nmf:}

\itemize{
\item \code{nmf(x = mMatrix,rank = NMF,method = ANY)}: Fits an NMF model using the NMF model \code{rank} to seed the computation,
i.e. as a starting point.

This method is provided for convenience as a shortcut for
\code{nmf(x, nbasis(object), method, seed=object, ...)}
It discards any value passed in argument \code{seed} and uses the NMF model passed
in \code{rank} instead.
It throws a warning if argument \code{seed} not missing.

If \code{method} is missing, this method will call the method
\code{nmf,matrix,numeric,NULL}, which will infer an algorithm suitable for fitting an
NMF model of the class of \code{rank}.
}


\bold{nmf.equal:}

\itemize{
\item \code{nmf.equal(x = NMF,y = NMF)}: Compares two NMF models.

Arguments in \code{...} are used only when \code{identical=FALSE} and are
passed to \code{all.equal}.

\item \code{nmf.equal(x = NMFfit,y = NMF)}: Compares two NMF models when at least one comes from a NMFfit object,
i.e. an object returned by a single run of \code{\link{nmf}}.

\item \code{nmf.equal(x = NMF,y = NMFfit)}: Compares two NMF models when at least one comes from a NMFfit object,
i.e. an object returned by a single run of \code{\link{nmf}}.

\item \code{nmf.equal(x = NMFfitX,y = NMF)}: Compares two NMF models when at least one comes from multiple NMF runs.

\item \code{nmf.equal(x = NMF,y = NMFfitX)}: Compares two NMF models when at least one comes from multiple NMF runs.
}


\bold{nneg:}

\itemize{
\item \code{nneg(object = NMF)}: Apply \code{nneg} to the basis matrix of an \code{\link{NMF}}
object (i.e. \code{basis(object)}).
All extra arguments in \code{...} are passed to the method \code{nneg,matrix}.
}


\bold{nrun:}

\itemize{
\item \code{nrun(object = NMF)}: This default fallback method always returns \code{1L}.
}


\bold{predict:}

\itemize{
\item \code{predict(object = NMF)}: Default method for NMF models
}


\bold{profcor:}

\itemize{
\item \code{profcor(x = NMF,y = matrix)}: Computes the correlations between the basis profiles of \code{x} and
the rows of \code{y}.

\item \code{profcor(x = matrix,y = NMF)}: Computes the correlations between the rows of \code{x} and the basis
profiles of \code{y}.

\item \code{profcor(x = NMF,y = NMF)}: Computes the correlations between the basis profiles of \code{x} and \code{y}.

\item \code{profcor(x = NMF,y = missing)}: Computes the correlations between the basis profiles of \code{x}.
}


\bold{rmatrix:}

\itemize{
\item \code{rmatrix(x = NMF)}: Returns the target matrix estimate of the NMF model \code{x}, perturbated by
adding a random matrix generated using the default method of \code{rmatrix}:
it is a equivalent to \code{fitted(x) + rmatrix(fitted(x), ...)}.

This method can be used to generate random target matrices that depart from
a known NMF model to a controlled extend.
This is useful to test the robustness of NMF algorithms to the presence of
certain types of noise in the data.
}


\bold{rnmf:}

\itemize{
\item \code{rnmf(x = NMF,target = numeric)}: Generates a random NMF model of the same class and rank as another NMF model.

This is the workhorse method that is eventually called by all other methods.
It generates an NMF model of the same class and rank as \code{x}, compatible with the
dimensions specified in \code{target}, that can be a single or 2-length
numeric vector, to specify a square or rectangular target matrix respectively.

The second dimension can also be passed via argument \code{ncol}, so that
calling \code{rnmf(x, 20, 10, ...)} is equivalent to \code{rnmf(x, c(20, 10), ...)},
but easier to write.

The entries are uniformly drawn between \code{0} and \code{max}
(optionally specified in \code{...}) that defaults to 1.

By default the dimnames of \code{x} are set on the returned NMF model.
This behaviour is disabled with argument \code{keep.names=FALSE}.
See \code{\link{nmfModel}}.

\item \code{rnmf(x = NMF,target = missing)}: Generates a random NMF model of the same dimension as another NMF model.

It is a shortcut for \code{rnmf(x, nrow(x), ncol(x), ...)}, which returns
a random NMF model of the same class and dimensions as \code{x}.
}


\bold{rposneg:}

\itemize{
\item \code{rposneg(object = NMF)}: Apply \code{rposneg} to the basis matrix of an \code{\link{NMF}} object.
}


\bold{seed:}

\itemize{
\item \code{seed(x = mMatrix,model = NMF,method = NMFSeed)}: This is the workhorse method that seeds an NMF model object using a given
seeding strategy defined by an \code{NMFSeed} object, to fit a given
target matrix.
}


\bold{show:}

\itemize{
\item \code{show(object = NMF)}: Show method for objects of class \code{NMF}
}


\bold{sparseness:}

\itemize{
\item \code{sparseness(x = NMF)}: Compute the sparseness of an object of class \code{NMF}, as the sparseness of
the basis and coefficient matrices computed separately.

It returns the two values in a numeric vector with names \sQuote{basis} and \sQuote{coef}.
}

}


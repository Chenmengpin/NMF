% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/NMF-class.R, R/transforms.R, R/fixed-terms.R,
%   R/NMFfit-class.R, R/NMFSet-class.R, R/NMFplots.R
\docType{class}
\name{NMF-class}
\alias{NMF-class}
\alias{fitted,NMF-method}
\alias{.basis,NMF-method}
\alias{.basis<-,NMF,mMatrix-method}
\alias{.coef,NMF-method}
\alias{.coef<-,NMF,mMatrix-method}
\alias{scoef,NMF-method}
\alias{scale.NMF}
\alias{show,NMF-method}
\alias{misc}
\alias{$,NMF-method}
\alias{$<-,NMF-method}
\alias{.DollarNames.NMF}
\alias{.DollarNames,NMF-method}
\alias{rmatrix,NMF-method}
\alias{sparseness,NMF-method}
\alias{basiscor,NMF,matrix-method}
\alias{basiscor,matrix,NMF-method}
\alias{basiscor,NMF,NMF-method}
\alias{basiscor,NMF,missing-method}
\alias{profcor,NMF,matrix-method}
\alias{profcor,matrix,NMF-method}
\alias{profcor,NMF,NMF-method}
\alias{profcor,NMF,missing-method}
\alias{connectivity,NMF-method}
\alias{anyNA.NMF}
\alias{t.NMF}
\alias{c,NMF-method}
\alias{ibterms,NMF-method}
\alias{icterms,NMF-method}
\alias{nmf.equal,NMF,NMFfit-method}
\alias{nrun,NMF-method}
\alias{consensus,NMF-method}
\alias{nmf.equal,NMF,NMFfitX-method}
\alias{silhouette.NMF}
\title{Generic Interface for Nonnegative Matrix Factorisation Models}
\usage{
\S4method{fitted}{NMF}(object, ...)

\S4method{.basis}{NMF}(object, ...)

\S4method{.basis}{NMF,mMatrix}(object) <- value

\S4method{.coef}{NMF}(object, ...)

\S4method{.coef}{NMF,mMatrix}(object) <- value

\S4method{scoef}{NMF}(object, scale = 1)

\method{scale}{NMF}(x, center = c("basis", "coef"), scale = 1)

\S4method{show}{NMF}(object)

misc(object, ...)

\S4method{$}{NMF}(x, name)

\S4method{$}{NMF}(x, name) <- value

\method{.DollarNames}{NMF}(x, pattern = "")

\S4method{.DollarNames}{NMF}(x, pattern = "")

\S4method{rmatrix}{NMF}(x, ...)

\S4method{sparseness}{NMF}(x)

\S4method{basiscor}{NMF,matrix}(x, y, ...)

\S4method{basiscor}{matrix,NMF}(x, y, ...)

\S4method{basiscor}{NMF,NMF}(x, y, ...)

\S4method{basiscor}{NMF,missing}(x, y, ...)

\S4method{profcor}{NMF,matrix}(x, y, ...)

\S4method{profcor}{matrix,NMF}(x, y, ...)

\S4method{profcor}{NMF,NMF}(x, y, ...)

\S4method{profcor}{NMF,missing}(x, y, ...)

\S4method{connectivity}{NMF}(object, no.attrib = FALSE)

\method{anyNA}{NMF}(x, recursive = FALSE)

\method{t}{NMF}(x)

\S4method{c}{NMF}(x, ..., margin = 3L, recursive = FALSE)

\S4method{ibterms}{NMF}(object, ...)

\S4method{icterms}{NMF}(object, ...)

\S4method{nmf.equal}{NMF,NMFfit}(x, y, ...)

\S4method{nrun}{NMF}(object)

\S4method{consensus}{NMF}(object, ...)

\S4method{nmf.equal}{NMF,NMFfitX}(x, y, ...)

\method{silhouette}{NMF}(x, what = NULL, order = NULL, ...)
}
\arguments{
\item{object}{an object that inherit from class \code{NMF}}

\item{...}{extra arguments not used.}

\item{scale}{scaling coefficient applied to \eqn{D}, i.e. the value of \eqn{\alpha}{alpha},
or, if \code{center='coef'}, the value of \eqn{1/\alpha}{1/alpha} (see section \emph{Details}).}

\item{x}{an NMF object, as returned by \code{\link{nmf}}.}

\item{center}{either a numeric normalising vector \eqn{\delta}{delta}, or either
\code{'basis'} or \code{'coef'}, which respectively correspond to using the
column sums of the basis matrix or the inverse of the row sums of the
coefficient matrix as a normalising vector.
If numeric, \code{center} should be a single value or a vector of length the
rank of the NMF model, i.e. the number of columns in the basis matrix.}

\item{no.attrib}{a logical that indicates if attributes containing information
about the NMF model should be attached to the result (\code{TRUE}) or not
(\code{FALSE}).}

\item{margin}{integer that indicates the margin along which to concatenate
(only used when \code{..1} is a matrix):
\describe{
\item{1L}{}
\item{2L}{}
\item{3L}{}
\item{4L}{}
}
If missing the margin is heuristically determined by looking at common
dimensions between the objects.}

\item{what}{defines the type of clustering the computed silhouettes are
meant to assess: \code{'samples'} for the clustering of samples
(i.e. the columns of the target matrix),
\code{'features'} for the clustering of features (i.e. the rows of the
target matrix), and \code{'chc'} for the consensus clustering of samples as
defined by hierarchical clustering dendrogram, \code{'consensus'} for the
consensus clustering of samples, with clustered ordered as in the
\strong{default} hierarchical clustering used by
\code{\link{consensusmap}} when plotting the heatmap of the consensus matrix
(for multi-run NMF fits).
That is \code{dist = 1 - consensus(x)}, average linkage and reordering based
on row means.}

\item{order}{integer indexing vector that can be used to force the silhouette
order.}
}
\value{
an NMF object
}
\description{
The class \code{NMF} is a \emph{virtual class} that defines a common
interface to handle Nonnegative Matrix Factorization models (NMF models)
in a generic way.
Provided a minimum set of generic methods is implemented by concrete
model classes, these benefit from a whole set of functions and utilities
to perform common computations and tasks in the context of Nonnegative Matrix
Factorization.
}
\details{
Class \code{NMF} makes it easy to develop new models that integrate well
into the general framework implemented by the \emph{NMF} package.

Following a few simple guidelines, new types of NMF models benefit from all the
functionalities available for the built-in NMF models -- that derive themselves
from class \code{NMF}.
See section \emph{Implementing NMF models} below.

See \code{\linkS4class{NMFstd}}, and references and links therein for
details on the built-in implementations of the standard NMF model and its
extensions.
}
\section{Functions}{
\itemize{
\item \code{misc}: The function \code{misc} provides access to miscellaneous data members stored
in slot \code{misc} (as a \code{list}), which allow extensions of NMF models
to be implemented, without defining a new S4 class.
}}

\section{Slots}{

\describe{
\item{\code{misc}}{A list that is used internally to temporarily store algorithm
parameters during the computation.}
}}

\section{Implementing NMF models}{


The class \code{NMF} only defines a basic data/low-level interface for NMF models, as
a collection of generic methods, responsible with data handling, upon which
relies a comprehensive set of functions, composing a rich higher-level interface.

Actual NMF models are defined as sub-classes that inherits from class
\code{NMF}, and implement the management of data storage, providing
definitions for the interface's pure virtual methods.

The minimum requirement to define a new NMF model that integrates into
the framework of the \emph{NMF} package are the followings:

\itemize{

\item Define a class that inherits from class \code{NMF} and implements the
new model, say class \code{myNMF}.

\item Implement the following S4 methods for the new class \code{myNMF}:
\describe{
\item{fitted}{\code{signature(object = "myNMF", value = "matrix")}:
Must return the estimated target matrix as fitted by the NMF model
\code{object}.
}
\item{basis}{\code{signature(object = "myNMF")}:
Must return the basis matrix(e.g. the first matrix factor in
the standard NMF model).
}
\item{basis<-}{\code{signature(object = "myNMF", value = "matrix")}:
Must return \code{object} with the basis matrix set to
\code{value}.
}
\item{coef}{\code{signature(object = "myNMF")}:
Must return the matrix of mixture coefficients (e.g. the second matrix
factor in the standard NMF model).
}
\item{coef<-}{\code{signature(object = "myNMF", value = "matrix")}:
Must return \code{object} with the matrix of mixture coefficients set to
\code{value}.
}
}\preformatted{The \\emph\{NMF\} package provides "pure virtual" definitions of these
}

methods for class \code{NMF} (i.e. with signatures \code{(object='NMF', ...)}
and \code{(object='NMF', value='matrix')}) that throw an error if called, so
as to force their definition for model classes.

\item Optionally, implement method \code{rnmf}(signature(x="myNMF", target="ANY")).
This method should call \code{callNextMethod(x=x, target=target, ...)} and
fill the returned NMF model with its specific data suitable random values.
}

For concrete examples of NMF models implementations, see class
\code{\linkS4class{NMFstd}} and its extensions (e.g. classes
\code{\linkS4class{NMFOffset}} or \code{\linkS4class{NMFns}}).
}

\section{Creating NMF objects}{

Strictly speaking, because class \code{NMF} is virtual, no object of class
\code{NMF} can be instantiated, only objects from its sub-classes.
However, those objects are sometimes shortly referred in the documentation and
vignettes as "\code{NMF} objects" instead of "objects that inherits from
class \code{NMF}".

For built-in models or for models that inherit from the standard model class
\code{\linkS4class{NMFstd}}, the factory method \code{nmfModel} enables to easily create
valid \code{NMF} objects in a variety of common situations.
See documentation for the the factory method \code{\link{nmfModel}} for
more details.
}

\examples{

# show all the NMF models available (i.e. the classes that inherit from class NMF)
nmfModels()
# show all the built-in NMF models available
nmfModels(builtin.only=TRUE)

# class NMF is a virtual class so cannot be instantiated: 
try( new('NMF') )

# To instantiate an NMF model, use the factory method nmfModel. see ?nmfModel
nmfModel()
nmfModel(3)
nmfModel(3, model='NMFns')


# random 3-rank 10x5 NMF model
x <- rnmf(3, 10, 5)

# rescale based on basis
colSums(basis(x))
colSums(basis(scale(x)))

rx <- scale(x, 'basis', 10)
colSums(basis(rx))
rowSums(coef(rx))

# rescale based on coef
rowSums(coef(x))
rowSums(coef(scale(x, 'coef')))
rx <- scale(x, 'coef', 10)
rowSums(coef(rx))
colSums(basis(rx))

# fitted target matrix is identical but the factors have been rescaled
rx <- scale(x, 'basis')
all.equal(fitted(x), fitted(rx))
all.equal(basis(x), basis(rx))

# generate noisy fitted target from an NMF model (the true model)
gr <- as.numeric(mapply(rep, 1:3, 3))
h <- outer(1:3, gr, '==') + 0 
x <- rnmf(10, H=h)
y <- rmatrix(x)
\dontrun{
# show heatmap of the noisy target matrix: block patterns should be clear
aheatmap(y) 
}
\dontshow{ stopifnot( identical(dim(y), dim(x)[1:2]) ) }

# test NMF algorithm on noisy data
# add some noise to the true model (drawn from uniform [0,1])
res <- nmf(rmatrix(x), 3)
summary(res)

# add more noise to the true model (drawn from uniform [0,10])
res <- nmf(rmatrix(x, max=10), 3)
summary(res)


x <- rnmf(3, 100, 20)
x
# transpose
y <- t(x)
y

# factors are swapped-transposed
stopifnot( identical(basis(y), t(coef(x))) )
stopifnot( identical(coef(y), t(basis(x))) )


x <- rmatrix(100, 20, dimnames = list(paste0('a', 1:100), letters[1:20]))
# NB: using low value for maxIter for the example purpose only
res <- nmf(x, 4, nrun = 5, maxIter = 50)

# sample clustering from best fit
plot(silhouette(res))

# from consensus
plot(silhouette(res, what = 'consensus'))

# feature clustering
plot(silhouette(res, what = 'features')) 

# average silhouette are computed in summary measures
summary(res)

# consensus silhouettes are ordered as on default consensusmap heatmap
\dontrun{ op <- par(mfrow = c(1,2)) }
consensusmap(res)
si <- silhouette(res, what = 'consensus')
plot(si)
\dontrun{ par(op) }

# if the order is based on some custom numeric weights
\dontrun{ op <- par(mfrow = c(1,2)) }
cm <- consensusmap(res, Rowv = runif(ncol(res)))
# NB: use reverse order because silhouettes are plotted top-down
si <- silhouette(res, what = 'consensus', order = rev(cm$rowInd))
plot(si)
\dontrun{ par(op) }

# do the reverse: order the heatmap as a set of silhouettes
si <- silhouette(res, what = 'features')
\dontrun{ op <- par(mfrow = c(1,2)) } 
basismap(res, Rowv = si)
plot(si)
\dontrun{ par(op) }

}
\references{
Definition of Nonnegative Matrix Factorization in its modern formulation: Lee DD, Seung HS (1999). “Learning the parts of objects by non-negative matrix factorization.” _Nature_, *401*(6755), 788-91. ISSN
0028-0836, doi: 10.1038/44565 (URL: https://doi.org/10.1038/44565).

Historical first definition and algorithms: Paatero P, Tapper U (1994). “Positive matrix factorization: A non-negative factor model with optimal utilization of error estimates of
data values.” _Environmetrics_, *5*(2), 111-126. doi: 10.1002/env.3170050203 (URL: https://doi.org/10.1002/env.3170050203).
}
\seealso{
Main interface function \link{nmf} to perform NMF.

Built-in NMF models and factory method in \code{\link{nmfModel}}.

Method \code{\link{seed}} to set NMF objects with values suitable to start
algorithms with.

\code{\link[NMF]{predict}}

Other NMF-interface: 
\code{\link{basis}()},
\code{\link{nmfModel}()},
\code{\link{rnmf}()}

Other transforms: 
\code{\link{nneg}()}
}
\concept{NMF-interface}
\concept{NMF-model Implementations of NMF models}
\concept{transforms}
\keyword{internal}
\section{Methods (by generic)}{
\bold{.basis:}

\itemize{
\item \code{.basis(object = NMF)}: Pure virtual method for objects of class \code{\linkS4class{NMF}}, that
should be overloaded by sub-classes, and throws an error if called.
}


\bold{.basis<-:}

\itemize{
\item \code{.basis<-(object = NMF,value = mMatrix)}: Pure virtual method for objects of class \code{\linkS4class{NMF}}, that
should be overloaded by sub-classes, and throws an error if called.
}


\bold{.coef:}

\itemize{
\item \code{.coef(object = NMF)}: Pure virtual method for objects of class \code{\linkS4class{NMF}}, that
should be overloaded by sub-classes, and throws an error if called.
}


\bold{.coef<-:}

\itemize{
\item \code{.coef<-(object = NMF,value = mMatrix)}: Pure virtual method for objects of class \code{\linkS4class{NMF}}, that
should be overloaded by sub-classes, and throws an error if called.
}


\bold{[:}

\itemize{
\item \code{[(x = NMF,i = ANY,j = ANY,drop = ANY)}: Sub-setting NMF Objects

This method provides a convenient way of sub-setting objects of class \code{NMF},
using a matrix-like syntax.
}


\bold{$:}

\itemize{
\item \code{$(x = NMF)}: shortcut for \code{x@misc[[name, exact=TRUE]]} respectively.
}


\bold{$<-:}

\itemize{
\item \code{$<-(x = NMF)}: shortcut for \code{x@misc[[name]] <- value}
}


\bold{basis<-:}

\itemize{
\item \code{basis<-(object = NMF)}: Default methods that calls \code{.basis<-} and check the validity of the
updated object.
}


\bold{basiscor:}

\itemize{
\item \code{basiscor(x = NMF,y = matrix)}: Computes the correlations between the basis vectors of \code{x} and
the columns of \code{y}.

\item \code{basiscor(x = matrix,y = NMF)}: Computes the correlations between the columns of \code{x}
and the the basis vectors of \code{y}.

\item \code{basiscor(x = NMF,y = NMF)}: Computes the correlations between the basis vectors of \code{x} and \code{y}.

\item \code{basiscor(x = NMF,y = missing)}: Computes the correlations between the basis vectors of \code{x}.
}


\bold{basismap:}

\itemize{
\item \code{basismap(object = NMF)}: Plots a heatmap of the basis matrix of the NMF model \code{object}.
This method also works for fitted NMF models (i.e. \code{NMFfit} objects).
}


\bold{c:}

\itemize{
\item \code{c(x = NMF)}: Concatenating NMF Models

Binds compatible matrices and NMF models together.
}


\bold{canFit:}

\itemize{
\item \code{canFit(x = NMFStrategy,y = NMF)}: Tells if an NMF algorithm can fit the same class of models as \code{y}
}


\bold{coef<-:}

\itemize{
\item \code{coef<-(object = NMF)}: Default methods that calls \code{.coef<-} and check the validity of the
updated object.
}


\bold{coefficients:}

\itemize{
\item \code{coefficients(object = NMF)}: Alias to \code{coef,NMF}, therefore also pure virtual.
}


\bold{coefmap:}

\itemize{
\item \code{coefmap(object = NMF)}: The default method for NMF objects has special default values for
some arguments of \code{\link{aheatmap}} (see argument description).
}


\bold{connectivity:}

\itemize{
\item \code{connectivity(object = NMF)}: Computes the connectivity matrix for an NMF model, for which cluster
membership is given by the most contributing basis component in each sample.
See \code{\link{predict,NMF-method}}.
}


\bold{consensus:}

\itemize{
\item \code{consensus(object = NMF)}: This method is provided for completeness and is identical to
\code{\link{connectivity}}, and returns the connectivity matrix,
which, in the case of a single NMF model, is also the consensus matrix.
}


\bold{consensushc:}

\itemize{
\item \code{consensushc(object = NMF)}: Compute the hierarchical clustering on the connectivity matrix of \code{object}.
}


\bold{consensusmap:}

\itemize{
\item \code{consensusmap(object = NMF)}: Plots a heatmap of the connectivity matrix of an NMF model.
}


\bold{deviance:}

\itemize{
\item \code{deviance(object = NMF)}: Computes the distance between a matrix and the estimate of an \code{NMF} model.
}


\bold{dim:}

\itemize{
\item \code{dim(x = NMF)}: method for NMF objects for the base generic \code{\link{dim}}.
It returns all dimensions in a length-3 integer vector:
the number of row and columns of the estimated target matrix,
as well as the factorization rank (i.e. the number of basis components).
}


\bold{dimnames:}

\itemize{
\item \code{dimnames(x = NMF)}: Returns the dimension names of the NMF model \code{x}.

It returns either NULL if no dimnames are set on the object,
or a 3-length list containing the row names of the basis matrix,
the column names of the mixture coefficient matrix, and the column names of
the basis matrix (i.e. the names of the basis components).
}


\bold{dimnames<-:}

\itemize{
\item \code{dimnames<-(x = NMF,value = ANY)}: sets the dimension names of the NMF model \code{x}.

\code{value} can be \code{NULL} which resets all dimension names, or a
1, 2 or 3-length list providing names at least for the rows of the basis
matrix.

The optional second element of \code{value} (NULL if absent) is used to set
the column names of the coefficient matrix.
The optional third element of \code{value} (NULL if absent) is used to set
both the column names of the basis matrix and the row names of the
coefficient matrix.
}


\bold{extractFeatures:}

\itemize{
\item \code{extractFeatures(object = NMF)}: Select basis-specific features from an NMF model, by applying the method
\code{extractFeatures,matrix} to its basis matrix.
}


\bold{featureScore:}

\itemize{
\item \code{featureScore(object = NMF)}: Computes feature scores on the basis matrix of an NMF model.
}


\bold{fit<-:}

\itemize{
\item \code{fit<-(object = NMFfit,value = NMF)}: Updates the NMF model object stored in slot \code{'fit'} with a new value.
}


\bold{fitted:}

\itemize{
\item \code{fitted(object = NMF)}: Pure virtual method for objects of class \code{\linkS4class{NMF}}, that
should be overloaded by sub-classes, and throws an error if called.
}


\bold{ibterms:}

\itemize{
\item \code{ibterms(object = NMF)}: Default pure virtual method that ensure a method is defined for concrete
NMF model classes.
}


\bold{icterms:}

\itemize{
\item \code{icterms(object = NMF)}: Default pure virtual method that ensure a method is defined for concrete
NMF model classes.
}


\bold{loadings:}

\itemize{
\item \code{loadings(x = NMF)}: Method loadings for NMF Models

The method \code{loadings} is identical to \code{basis}, but do
not accept any extra argument.
}


\bold{metaHeatmap:}

\itemize{
\item \code{metaHeatmap(object = NMF)}: Deprecated method that is substituted by \code{\link{coefmap}} and \code{\link{basismap}}.
}


\bold{nmf:}

\itemize{
\item \code{nmf(x = mMatrix,rank = NMF,method = ANY)}: Fits an NMF model using the NMF model \code{rank} to seed the computation,
i.e. as a starting point.

This method is provided for convenience as a shortcut for
\code{nmf(x, nbasis(object), method, seed=object, ...)}
It discards any value passed in argument \code{seed} and uses the NMF model passed
in \code{rank} instead.
It throws a warning if argument \code{seed} not missing.

If \code{method} is missing, this method will call the method
\code{nmf,matrix,numeric,NULL}, which will infer an algorithm suitable for fitting an
NMF model of the class of \code{rank}.
}


\bold{nmf.equal:}

\itemize{
\item \code{nmf.equal(x = NMF,y = NMF)}: Compares two NMF models.

Arguments in \code{...} are used only when \code{identical=FALSE} and are
passed to \code{all.equal}.

\item \code{nmf.equal(x = NMFfit,y = NMF)}: Compares two NMF models when at least one comes from a NMFfit object,
i.e. an object returned by a single run of \code{\link{nmf}}.

\item \code{nmf.equal(x = NMFfitX,y = NMF)}: Compares two NMF models when at least one comes from multiple NMF runs.

\item \code{nmf.equal(x = NMF,y = NMFfit)}: Compares two NMF models when at least one comes from a NMFfit object,
i.e. an object returned by a single run of \code{\link{nmf}}.

\item \code{nmf.equal(x = NMF,y = NMFfitX)}: Compares two NMF models when at least one comes from multiple NMF runs.
}


\bold{nneg:}

\itemize{
\item \code{nneg(object = NMF)}: Apply \code{nneg} to the basis matrix of an \code{\link{NMF}}
object (i.e. \code{basis(object)}).
All extra arguments in \code{...} are passed to the method \code{nneg,matrix}.
}


\bold{nrun:}

\itemize{
\item \code{nrun(object = NMF)}: This default fallback method always returns \code{1L}.
}


\bold{predict:}

\itemize{
\item \code{predict(object = NMF)}: Default method for NMF models
}


\bold{profcor:}

\itemize{
\item \code{profcor(x = NMF,y = matrix)}: Computes the correlations between the basis profiles of \code{x} and
the rows of \code{y}.

\item \code{profcor(x = matrix,y = NMF)}: Computes the correlations between the rows of \code{x} and the basis
profiles of \code{y}.

\item \code{profcor(x = NMF,y = NMF)}: Computes the correlations between the basis profiles of \code{x} and \code{y}.

\item \code{profcor(x = NMF,y = missing)}: Computes the correlations between the basis profiles of \code{x}.
}


\bold{rmatrix:}

\itemize{
\item \code{rmatrix(x = NMF)}: Returns the target matrix estimate of the NMF model \code{x}, perturbated by
adding a random matrix generated using the default method of \code{rmatrix}:
it is a equivalent to \code{fitted(x) + rmatrix(fitted(x), ...)}.

This method can be used to generate random target matrices that depart from
a known NMF model to a controlled extend.
This is useful to test the robustness of NMF algorithms to the presence of
certain types of noise in the data.
}


\bold{rnmf:}

\itemize{
\item \code{rnmf(x = NMF,target = numeric)}: Generates a random NMF model of the same class and rank as another NMF model.

This is the workhorse method that is eventually called by all other methods.
It generates an NMF model of the same class and rank as \code{x}, compatible with the
dimensions specified in \code{target}, that can be a single or 2-length
numeric vector, to specify a square or rectangular target matrix respectively.

The second dimension can also be passed via argument \code{ncol}, so that
calling \code{rnmf(x, 20, 10, ...)} is equivalent to \code{rnmf(x, c(20, 10), ...)},
but easier to write.

The entries are uniformly drawn between \code{0} and \code{max}
(optionally specified in \code{...}) that defaults to 1.

By default the dimnames of \code{x} are set on the returned NMF model.
This behaviour is disabled with argument \code{keep.names=FALSE}.
See \code{\link{nmfModel}}.

\item \code{rnmf(x = NMF,target = missing)}: Generates a random NMF model of the same dimension as another NMF model.

It is a shortcut for \code{rnmf(x, nrow(x), ncol(x), ...)}, which returns
a random NMF model of the same class and dimensions as \code{x}.
}


\bold{rposneg:}

\itemize{
\item \code{rposneg(object = NMF)}: Apply \code{rposneg} to the basis matrix of an \code{\link{NMF}} object.
}


\bold{run:}

\itemize{
\item \code{run(object = NMFStrategy,y = mMatrix,x = NMF)}: Method to run an NMF algorithm directly starting from a given NMF model.
}


\bold{scale:}

\itemize{
\item \code{scale(NMF)}: Rescaling NMF Models

Rescales an NMF model keeping the fitted target matrix identical.

Standard NMF models are identifiable modulo a scaling factor, meaning that the
basis components and basis profiles can be rescaled without changing the fitted
values:

\deqn{X = W_1 H_1 = (W_1 D) (D^{-1} H_1) = W_2 H_2}{X = W H = (W D) (D^-1 H)}
with \eqn{D= \alpha diag(1/\delta_1, \ldots, 1\delta_r)}{D= alpha * diag(1/delta_1, ..., 1/delta_r)}

The default call \code{scale(object)} rescales the basis NMF object so that each
column of the basis matrix sums up to one.
}


\bold{seed:}

\itemize{
\item \code{seed(x = mMatrix,model = NMF,method = NMFSeed)}: This is the workhorse method that seeds an NMF model object using a given
seeding strategy defined by an \code{NMFSeed} object, to fit a given
target matrix.
}


\bold{show:}

\itemize{
\item \code{show(object = NMF)}: Show method for objects of class \code{NMF}
}


\bold{silhouette:}

\itemize{
\item \code{silhouette(NMF)}: Silhouette of NMF Clustering
}


\bold{sparseness:}

\itemize{
\item \code{sparseness(x = NMF)}: Compute the sparseness of an object of class \code{NMF}, as the sparseness of
the basis and coefficient matrices computed separately.

It returns the two values in a numeric vector with names \sQuote{basis} and \sQuote{coef}.
}


\bold{summary:}

\itemize{
\item \code{summary(object = NMF)}: Computes summary measures for a single NMF model.

The following measures are computed:
}


\bold{t:}

\itemize{
\item \code{t(NMF)}: Transformation of NMF Model Objects

\code{t} transpose an NMF model, by transposing and swapping its basis and
coefficient matrices: \eqn{t([W,H]) = [t(H), t(W)]}.

The function \code{t} is a generic defined in the \pkg{base} package.
The method \code{t.NMF} defines the trasnformation for the general NMF interface.
This method may need to be overloaded for NMF models, whose structure requires
specific handling.
}

}


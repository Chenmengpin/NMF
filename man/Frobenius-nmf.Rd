% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/algorithms-base.R
\name{nmf_update.lee_R}
\alias{nmf_update.lee_R}
\alias{Frobenius-nmf}
\alias{nmf_update.lee}
\alias{nmfAlgorithm.lee_R}
\alias{lee_R-nmf}
\alias{nmfAlgorithm.lee}
\alias{lee-nmf}
\alias{nmfAlgorithm.Frobenius}
\title{NMF Algorithm/Updates for Frobenius Norm}
\usage{
nmf_update.lee_R(i, v, x, rescale = TRUE, eps = 10^-9, ...)

nmf_update.lee(
  i,
  v,
  x,
  rescale = TRUE,
  copy = FALSE,
  eps = 10^-9,
  weight = NULL,
  ...
)

nmfAlgorithm.lee_R(
  ...,
  .stop = NULL,
  maxIter = nmf.getOption("maxIter") \%||\% 2000,
  rescale = TRUE,
  eps = 10^-9,
  stopconv = 40,
  check.interval = 10
)

nmfAlgorithm.lee(
  ...,
  .stop = NULL,
  maxIter = nmf.getOption("maxIter") \%||\% 2000,
  rescale = TRUE,
  copy = FALSE,
  eps = 10^-9,
  weight = NULL,
  stopconv = 40,
  check.interval = 10
)

nmfAlgorithm.Frobenius(
  ...,
  .stop = NULL,
  maxIter = nmf.getOption("maxIter") \%||\% 2000,
  rescale = TRUE,
  copy = FALSE,
  eps = 10^-9,
  weight = NULL,
  stationary.th = .Machine$double.eps,
  check.interval = 5 * check.niter,
  check.niter = 10L
)
}
\arguments{
\item{i}{current iteration number.}

\item{v}{target matrix.}

\item{x}{current NMF model, as an \code{\linkS4class{NMF}} object.}

\item{rescale}{logical that indicates if the basis matrix \eqn{W} should be
rescaled so that its columns sum up to one.}

\item{eps}{small numeric value used to ensure numeric stability, by shifting up
entries from zero to this fixed value.}

\item{...}{extra arguments. These are generally not used and present
only to allow other arguments from the main call to be passed to the
initialisation and stopping criterion functions (slots \code{onInit} and
\code{Stop} respectively).}

\item{copy}{logical that indicates if the update should be made on the original
matrix directly (\code{FALSE}) or on a copy (\code{TRUE} - default).
With \code{copy=FALSE} the memory footprint is very small, and some speed-up may be
achieved in the case of big matrices.
However, greater care should be taken due the side effect.
We recommend that only experienced users use \code{copy=TRUE}.}

\item{weight}{numeric vector of sample weights, e.g., used to normalise samples
coming from multiple datasets.
It must be of the same length as the number of samples/columns in \code{v}
-- and \code{h}.}

\item{stopconv}{number of iterations intervals over which the connectivity
matrix must not change for stationarity to be achieved.}

\item{check.interval}{interval (in number of iterations) on which the stopping
criterion is computed.}

\item{stationary.th}{maximum absolute value of the gradient, for the objective
function to be considered stationary.}

\item{check.niter}{number of successive iteration used to compute the stationnary
criterion.}
}
\description{
The built-in NMF algorithms described here minimise
the Frobenius norm (Euclidean distance) between an NMF model and a target matrix.
They use the updates for the basis and coefficient matrices (\eqn{W} and \eqn{H})
defined by Lee and Seung (2001).
}
\details{
\code{nmf_update.lee_R} implements in pure R a single update step, i.e. it updates
both matrices.
}
\references{
Lee DD, Seung H (2001). “Algorithms for non-negative matrix
factorization.” _Advances in neural information processing systems_.
<URL:
http://scholar.google.com/scholar?q=intitle:Algorithms+for+non-negative+matrix+factorization\#0>.
}
\author{
Original update definition: D D Lee and HS Seung

Port to R and optimisation in C++: Renaud Gaujoux
}
